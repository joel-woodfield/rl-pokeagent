<!DOCTYPE html>
<html>
<head>
    <title>PokeAgent Challenge - Speedrun</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        html, body {
            font-family: 'VT323', monospace;
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            color: #33ff33;
            width: 1920px;
            height: 1080px;
            overflow: hidden;
            letter-spacing: 1px;
        }
        
        body {
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background-color: #1a1a1a;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            border-bottom: 2px solid #33ff33;
            height: 60px;
            box-sizing: border-box;
        }
        
        .header-logo {
            color: #ff6177;
            font-weight: bold;
            margin-right: 20px;
            text-shadow: 0 0 5px #ff6177;
            font-size: 24px;
        }
        
        .header-title {
            color: #33ff33;
            font-size: 20px;
        }
        
        .content {
            display: flex;
            height: 1020px;
            padding: 10px;
            gap: 10px;
            box-sizing: border-box;
        }
        
        .game-panel {
            width: 895px;
            height: 890px;
            display: flex;
            flex-direction: column;
            background-color: #1a1a1a;
            border-radius: 0;
            overflow: hidden;
            border: 1px solid #33ff33;
            box-sizing: border-box;
        }
        
        .frame-container {
            width: 895px;
            height: 890px;
            margin: 0 auto;
            position: relative;
            background-color: #000000;
            border: 1px solid #33ff33;
            box-shadow: 0 0 10px #33ff33;
            box-sizing: border-box;
            padding: 0;
            overflow: hidden;
            /* Game frame: 972px total - 140px milestones - 150px actions = 682px */
        }
        
        .frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }
        
        .milestones {
            padding: 15px;
            background-color: #1a1a1a;
            border-top: 1px solid #33ff33;
            height: 200px;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .action-section {
            background-color: #1a1a1a;
            border-top: 1px solid #33ff33;
            padding: 15px;
            height: 150px;
            box-sizing: border-box;
        }
        
        .milestones-container {
            height: 140px;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .milestones-container::-webkit-scrollbar {
            width: 4px;
        }
        
        .milestones-container::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .milestones-container::-webkit-scrollbar-thumb {
            background: #33ff33;
            border-radius: 2px;
        }
        
        .milestones-container::-webkit-scrollbar-thumb:hover {
            background: #ff6177;
        }
        
        .milestone-title {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .milestone-icon {
            margin-right: 10px;
        }
        
        .milestone-progress {
            flex: 1;
            height: 2px;
            background-color: #666;
            margin: 0 10px;
            box-shadow: 0 0 5px #33ff33;
            position: relative;
        }

        .milestone-progress-fill {
            height: 100%;
            background-color: #33ff33;
        }
        
        .milestone-count {
            color: #ff6177;
        }
        
        .milestone-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            color: #33ff33;
            font-size: 12px;
        }
        
        .milestone-check {
            color: #ff6177;
            margin-left: auto;
            text-shadow: 0 0 5px #ff6177;
        }

        .milestone-category {
            display: inline-block;
            background-color: #0a0a0a;
            border: 1px solid #666;
            color: #666;
            padding: 1px 4px;
            font-size: 10px;
            margin-right: 8px;
            min-width: 50px;
            text-align: center;
        }

        .milestone-category.location { border-color: #33ff33; color: #33ff33; }
        .milestone-category.pokemon { border-color: #ffff33; color: #ffff33; }
        .milestone-category.badge { border-color: #ff6177; color: #ff6177; }
        .milestone-category.progress { border-color: #33ffff; color: #33ffff; }
        
        .milestone-name.newest {
            color: #ff6177;
            text-shadow: 0 0 5px #ff6177;
            font-weight: bold;
        }
        
        .milestone-name.recent {
            color: #33ff33;
        }
        
        .milestone-name.older {
            color: #999;
        }
        
        .brain-panel {
            width: 1080px;
            height: 972px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-sizing: border-box;
        }
        
        .brain-section {
            background-color: #1a1a1a;
            border-radius: 0;
            padding: 15px;
            border: 1px solid #33ff33;
            box-sizing: border-box;
        }
        
        .brain-section:nth-child(1) { height: 400px; } /* Agent Thinking */
        .brain-section:nth-child(2) { height: 520px; } /* Party Status */
        
        .section-title {
            color: #ff6177;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 0 0 5px #ff6177;
        }
        
        .agent-thinking {
            height: 340px;
            line-height: 1.6;
            overflow-y: auto;
            padding: 5px;
            background-color: #0a0a0a;
            border: 1px solid #33ff33;
            font-family: 'VT323', monospace;
            font-size: 16px;
            word-wrap: break-word;
            white-space: normal;
            text-align: left;
        }

        .llm-entry {
            margin-bottom: 4px;
            font-size: 16px;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.4;
            text-align: left;
            display: block;
            padding: 0;
            margin-left: 0;
        }

        .llm-step {
            color: #ff6177;
            font-weight: bold;
            margin-right: 8px;
            display: inline;
            float: none;
        }

        /* Streaming-specific styles */
        .llm-entry.streaming {
            border-left: 3px solid #ffa500;
            background-color: rgba(255, 165, 0, 0.1);
            padding: 8px;
            margin-bottom: 8px;
        }

        .llm-entry.complete {
            border-left: 3px solid #00ff00;
            background-color: rgba(0, 255, 0, 0.05);
            padding: 8px;
            margin-bottom: 8px;
        }

        .llm-message {
            color: #ddd;
            margin: 5px 0;
        }

        .llm-meta {
            color: #888;
            font-size: 12px;
            font-style: italic;
            margin-top: 5px;
        }

        .status-message {
            color: #ffa500;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .error-message {
            color: #ff6b6b;
            font-style: italic;
            text-align: center;
            padding: 10px;
        }

        .llm-message {
            color: #33ff33;
            word-wrap: break-word;
            white-space: normal;
            display: inline;
            float: none;
            padding: 0;
            margin: 0;
        }



        .action-queue {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            height: 90px;
            overflow-y: auto;
        }

        .action-button {
            background-color: #0a0a0a;
            border: 1px solid #33ff33;
            color: #33ff33;
            padding: 5px 10px;
            font-family: 'VT323', monospace;
            font-size: 12px;
            border-radius: 0;
        }

        .action-button.newest {
            border-color: #ff6177;
            box-shadow: 0 0 10px #ff6177;
        }
        
        .game-state {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 460px;
            overflow-y: auto;
        }

        .party-pokemon {
            background-color: #0a0a0a;
            border: 1px solid #33ff33;
            padding: 10px;
            margin-bottom: 5px;
        }

        .pokemon-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .pokemon-name {
            font-weight: bold;
            color: #ff6177;
        }

        .pokemon-level {
            color: #33ff33;
        }
        
        .pokemon-stats {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }

        .pokemon-hp {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .hp-bar {
            height: 8px;
            background-color: #333;
            border-radius: 0;
            width: 80px;
            position: relative;
            box-shadow: 0 0 5px #33ff33;
        }

        .hp-fill {
            height: 100%;
            background-color: #33ff33;
        }

        .hp-fill.low {
            background-color: #ff6177;
        }

        .hp-fill.critical {
            background-color: #ff0000;
        }

        .pokemon-moves {
            margin-top: 8px;
            font-size: 12px;
        }

        .move-item {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
            color: #666;
        }

        .move-name {
            color: #33ff33;
        }
        


        /* CRT effect */
        .crt-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        .crt-flicker {
            display: none; /* Disabled for performance */
        }
    </style>
</head>
<body>
    <div class="crt-lines"></div>
    <div class="crt-flicker"></div>
    <div class="header">
        <div class="header-logo">PokeAgent Challenge //</div>
        <div class="header-title">PROTOCOL_EMERALD // AGENT = PLAYER</div>
        <div style="flex: 1;"></div>
        <div id="metrics-display" style="color: #33ff33; margin-right: 20px; font-size: 14px;">
            <span id="cost-metric">Cost: $0.00</span> | 
            <span id="tokens-metric">0 tokens</span> | 
            <span id="actions-metric">Actions: 0</span> | 
            <span id="time-metric">Time: 00:00:00</span>
        </div>
        <div style="width: 10px; height: 10px; background-color: #33ff33; border-radius: 50%; box-shadow: 0 0 10px #33ff33;"></div>
    </div>
    
    <div class="content">
        <div class="game-panel">
            <div class="frame-container">
                <img id="frame" class="frame" src="" alt="Game Frame">
            </div>
            
                        <div class="milestones">
                <div class="milestone-title">
                    <span class="milestone-icon">■</span>
                    <span>SYSTEM.LOG - RECENT MILESTONES</span>
                    <div class="milestone-progress">
                        <div id="milestone-progress-fill" class="milestone-progress-fill" style="width: 0%"></div>
                    </div>
                    <span id="milestone-count" class="milestone-count">0/0</span>
                </div>
                <div class="milestones-container">
                <div id="milestones-list">
                    <!-- Milestones will be added here -->
                    </div>
                </div>
            </div>
            
            <div class="action-section">
                <div class="section-title"># ACTION_QUEUE</div>
                <div id="action-queue" class="action-queue">
                    <!-- Recent button presses will appear here -->
                </div>
            </div>
        </div>
        
        <div class="brain-panel">
            <div class="brain-section">
                <div class="section-title"># AGENT_THINKING</div>
                <div id="agent-thinking" class="agent-thinking">INITIALIZING AGENT...</div>
            </div>
            
            <div class="brain-section">
                <div class="section-title">◑ PARTY_STATUS</div>
                <div id="party-status" class="game-state">
                    <div class="party-pokemon">
                        <div class="pokemon-header">
                            <span class="pokemon-name">LOADING...</span>
                            <span class="pokemon-level">Lv.??</span>
                        </div>
                        <div class="pokemon-hp">
                            <span>HP:</span>
                            <div class="hp-bar">
                                <div class="hp-fill" style="width: 0%"></div>
                    </div>
                            <span>--/--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let isConnected = false;
        let frameUpdateInterval;
        
        // Detect server address dynamically
        const serverUrl = `http://${window.location.hostname}:${window.location.port || '8000'}`;
        const frameServerUrl = `http://${window.location.hostname}:8001`; // Separate frame server
        console.log(`Using server URL: ${serverUrl}`);
        console.log(`Using frame server URL: ${frameServerUrl}`);
        
        // Poll for frame updates using FastAPI with robust error handling
        let consecutiveErrors = 0;
        let pollInterval = 25; // Start with 25ms (40 FPS) - better match for 120 FPS emulator
        const maxInterval = 200; // Max 200ms for faster recovery
        const maxConsecutiveErrors = 5;
        
        async function pollFrameUpdate() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
                
                const response = await fetch(`${frameServerUrl}/frame`, {
                    signal: controller.signal,
                    method: 'GET',
                    cache: 'no-cache'
                });
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.frame) {
                        document.getElementById('frame').src = `data:image/png;base64,${data.frame}`;
                    }
                    
                    // Reset error tracking on success
                    consecutiveErrors = 0;
                    pollInterval = 25; // Reset to fast polling (40 FPS)
                    
                    if (!isConnected) {
                        isConnected = true;
                        console.log('FastAPI connected');
                        document.querySelector('.header div[style*="background-color"]').style.backgroundColor = '#33ff33';
                    }
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                consecutiveErrors++;
                
                // Exponential backoff for polling interval
                if (consecutiveErrors > 2) {
                    pollInterval = Math.min(pollInterval * 1.5, maxInterval);
                    clearInterval(frameUpdateInterval);
                    frameUpdateInterval = setInterval(pollFrameUpdate, pollInterval);
                }
                
                if (isConnected || consecutiveErrors === 1) {
                    isConnected = false;
                    console.log(`FastAPI disconnected (${consecutiveErrors} errors): ${error.message}`);
                    document.querySelector('.header div[style*="background-color"]').style.backgroundColor = '#ff6177';
                }
                
                // Log only every 5th consecutive error to avoid spam
                if (consecutiveErrors % 5 === 0) {
                    console.warn(`${consecutiveErrors} consecutive connection errors, polling every ${pollInterval}ms`);
                }
            }
        }
        
        // Function to format time from seconds to HH:MM:SS
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
        
        // Track session start time for continuous timer
        let sessionStartTime = null;
        let savedRunTime = 0;
        
        // Function to update metrics display
        async function updateMetrics() {
            try {
                const response = await fetch(`${serverUrl}/metrics`);
                if (response.ok) {
                    const metrics = await response.json();
                    
                    // Update cost display
                    const cost = metrics.total_cost || 0;
                    document.getElementById('cost-metric').textContent = `Cost: $${cost.toFixed(4)}`;
                    
                    // Update tokens display
                    const tokens = metrics.total_tokens || 0;
                    document.getElementById('tokens-metric').textContent = `${tokens.toLocaleString()} tokens`;
                    
                    // Update actions display
                    const actions = metrics.total_actions || 0;
                    document.getElementById('actions-metric').textContent = `Actions: ${actions.toLocaleString()}`;
                    
                    // Handle start time - detect fresh start if metrics are all zero
                    const isNewSession = metrics.total_llm_calls === 0 && metrics.total_actions === 0 && metrics.total_cost === 0;
                    
                    if (isNewSession) {
                        // Fresh start - reset timer and force immediate update
                        sessionStartTime = null;
                        savedRunTime = 0;
                        console.log('Detected fresh session - resetting timer');
                        
                        // Force an immediate metrics update in case server cache is stale
                        setTimeout(() => {
                            updateMetrics();
                        }, 500);
                    } else if (metrics.start_time && !sessionStartTime) {
                        // Restore from checkpoint or first metrics update
                        sessionStartTime = metrics.start_time * 1000; // Convert to milliseconds
                        savedRunTime = metrics.total_run_time || 0;
                        console.log('Initialized timer from metrics:', {
                            startTime: metrics.start_time,
                            savedRunTime: savedRunTime
                        });
                    }
                }
            } catch (error) {
                console.error('Error fetching metrics:', error);
            }
        }
        
        // Function to update time continuously
        function updateTime() {
            if (sessionStartTime) {
                const currentTime = Date.now();
                const elapsedSeconds = Math.floor((currentTime - sessionStartTime) / 1000) + savedRunTime;
                document.getElementById('time-metric').textContent = `Time: ${formatTime(elapsedSeconds)}`;
            } else {
                // No session started yet - show 00:00:00
                document.getElementById('time-metric').textContent = `Time: 00:00:00`;
            }
        }
        
        // Poll for metrics updates - reduced frequency for better performance  
        setInterval(updateMetrics, 2000);  // Update metrics every 2 seconds (reduced from 1s)
        setInterval(updateTime, 500);  // Update timer every 500ms (reduced from 100ms) 
        updateMetrics();  // Initial metrics load
        
        // Start polling every 25ms (40 FPS) to better match 120 FPS emulator
        frameUpdateInterval = setInterval(pollFrameUpdate, 25);
        
        // Initial connection attempt
        pollFrameUpdate();

        // Streaming agent thinking using Server-Sent Events
        let streamingSource = null;
        let currentMessage = null;
        let isMessageComplete = true;
        
        function initializeAgentStreaming() {
            const agentThinkingDiv = document.getElementById('agent-thinking');
            
            // Close existing connection if any
            if (streamingSource) {
                streamingSource.close();
            }
            
            // Create new EventSource connection
            streamingSource = new EventSource(`${serverUrl}/agent_stream`);
            
            streamingSource.onopen = function(event) {
                console.log('Agent streaming connected');
                agentThinkingDiv.innerHTML = '<div class="status-message">Agent streaming connected...</div>';
            };
            
            streamingSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.error) {
                        console.error('Streaming error:', data.error);
                        return;
                    }
                    
                    // Ignore heartbeat messages
                    if (data.heartbeat) {
                        return;
                    }
                    
                    // Only process new messages
                    if (!data.is_new) {
                        return;
                    }
                    
                    console.log('New agent message received:', data.step);
                    
                    // Create new message element
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'llm-entry streaming';
                    messageDiv.innerHTML = `
                        <div class="llm-step">Step ${data.step}:</div>
                        <div class="llm-message" id="streaming-message-${data.step}-${Date.now()}"></div>
                        <div class="llm-meta">${data.type} (${data.duration?.toFixed(2)}s)</div>
                    `;
                    
                    // Add to container
                    agentThinkingDiv.appendChild(messageDiv);
                    
                    // Stream the response text word by word
                    const messageElement = messageDiv.querySelector('.llm-message');
                    const responseText = data.response || '';
                    
                    // Split text into words while preserving whitespace and punctuation
                    const words = responseText.split(/(\s+)/).filter(w => w.length > 0);
                    let wordIndex = 0;
                    
                    function typeWord() {
                        if (wordIndex < words.length) {
                            messageElement.textContent += words[wordIndex];
                            wordIndex++;
                            // Auto-scroll as text appears
                            agentThinkingDiv.scrollTop = agentThinkingDiv.scrollHeight;
                            
                            // Faster typing for better performance (reduced delay)
                            const delay = words[wordIndex - 1].trim() === '' ? 2 : 10; // 2ms for spaces, 10ms for words (faster)
                            setTimeout(typeWord, delay);
                        } else {
                            // Message complete
                            messageDiv.classList.remove('streaming');
                            messageDiv.classList.add('complete');
                            console.log('Message complete for step:', data.step);
                        }
                    }
                    
                    typeWord();
                    
                } catch (error) {
                    console.error('Error parsing streaming data:', error);
                }
            };
            
            streamingSource.onerror = function(event) {
                console.error('Agent streaming error:', event);
                agentThinkingDiv.innerHTML = '<div class="error-message">Agent streaming disconnected. Retrying...</div>';
                
                // Retry connection after delay
                setTimeout(() => {
                    initializeAgentStreaming();
                }, 5000);
            };
        }
        
        // Fallback function for non-streaming updates
        async function updateAgentThinking() {
            // Only use fallback if streaming is not available
            if (streamingSource && streamingSource.readyState === EventSource.OPEN) {
                return;
            }
            
            try {
                const response = await fetch(`${serverUrl}/agent`);
                const data = await response.json();
                
                const agentThinkingDiv = document.getElementById('agent-thinking');
                
                if (data.recent_interactions && data.recent_interactions.length > 0) {
                    // Format all LLM interactions in condensed format: "Step X: <msg>"
                    let html = '';
                    data.recent_interactions.forEach((interaction, index) => {
                        // Calculate step number based on current step and interaction index
                        const baseStep = data.current_step || 0;
                        const stepNumber = baseStep;
                        
                        // Trim whitespace from the response
                        const trimmedResponse = interaction.response.trim();
                        
                        html += `<div class="llm-entry complete">
                            <div class="llm-step">Step ${stepNumber}:</div>
                            <div class="llm-message">${trimmedResponse}</div>
                        </div>`;
                    });
                    agentThinkingDiv.innerHTML = html;
                    
                    // Auto-scroll to bottom to show most recent
                    agentThinkingDiv.scrollTop = agentThinkingDiv.scrollHeight;
                } else {
                    agentThinkingDiv.textContent = data.current_thought || 'No recent LLM interactions';
                }
                
            } catch (error) {
                console.error('Error fetching agent thinking:', error);
                document.getElementById('agent-thinking').textContent = 'Error loading agent thinking';
            }
        }

        // Function to fetch and update recent actions
        let lastButtonCount = 0;
        let lastButtonData = '';
        
        async function updateRecentActions() {
            try {
                const response = await fetch(`${serverUrl}/recent_actions`);
                const data = await response.json();
                
                const actionQueue = document.getElementById('action-queue');
                
                // Get up to last 20 button presses (or fewer if less available)
                const recentButtons = data.recent_buttons.slice(-20);
                
                // Create a signature of current buttons for change detection
                const currentSignature = recentButtons.map(b => `${b.button}:${b.timestamp}`).join('|');
                
                // Only update if there are changes
                if (currentSignature === lastButtonData && recentButtons.length === lastButtonCount) {
                    return; // No changes, don't update
                }
                
                lastButtonData = currentSignature;
                lastButtonCount = recentButtons.length;
                
                actionQueue.innerHTML = ''; // Clear existing buttons
                
                // Only show actual buttons (no empty slots)
                if (recentButtons.length === 0) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.style.color = '#666';
                    emptyMessage.style.fontStyle = 'italic';
                    emptyMessage.textContent = 'NO_RECENT_ACTIONS';
                    actionQueue.appendChild(emptyMessage);
                    return;
                }
                
                recentButtons.forEach((buttonData, index) => {
                    const button = document.createElement('div');
                    button.className = 'action-button';
                    button.textContent = buttonData.button;
                    
                    // Calculate age-based opacity (newer = more opaque)
                    const age = recentButtons.length - index - 1; // 0 = newest
                    const maxAge = Math.min(recentButtons.length - 1, 19); // Handle fewer than 20 buttons
                    const opacity = maxAge > 0 ? Math.max(0.3, 1.0 - (age / maxAge) * 0.7) : 1.0;
                    button.style.opacity = opacity;
                    
                    // Highlight the most recent button
                    if (index === recentButtons.length - 1) {
                        button.classList.add('newest');
                    }
                    
                    actionQueue.appendChild(button);
                });
                
            } catch (error) {
                console.error('Error fetching recent actions:', error);
            }
        }

        // Function to fetch and update milestones
        async function updateMilestones() {
            try {
                const response = await fetch(`${serverUrl}/milestones`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                console.log('Milestone data received:', data); // Debug log
                
                // Update progress bar and count (show recent out of completed)
                const recentCount = Math.min(data.completed, 8);
                document.getElementById('milestone-count').textContent = `${recentCount}/${data.completed} RECENT`;
                document.getElementById('milestone-progress-fill').style.width = `${data.progress * 100}%`;
                
                // Update milestone list - GET ELEMENT FIRST!
                const milestonesList = document.getElementById('milestones-list');
                milestonesList.innerHTML = '';
                
                // Filter and show only recent completed milestones (max 8)
                if (data.milestones && data.milestones.length > 0) {
                    // Get only completed milestones, sorted by timestamp (most recent first)
                    const completedMilestones = data.milestones
                        .filter(milestone => milestone.completed)
                        .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0))
                        .slice(0, 8); // Show max 8 recent milestones
                    
                    if (completedMilestones.length > 0) {
                        completedMilestones.forEach((milestone, index) => {
                            const item = document.createElement('div');
                            item.className = 'milestone-item';
                            
                            const categoryClass = milestone.category || 'basic';
                            const categoryDisplay = categoryClass.toUpperCase().substring(0, 4);
                            
                            // Add age indicator for visual feedback
                            const ageClass = index === 0 ? 'newest' : index < 3 ? 'recent' : 'older';
                            
                            item.innerHTML = `
                                <span class="milestone-category ${categoryClass}">${categoryDisplay}</span>
                                <span class="milestone-name ${ageClass}">${milestone.name}</span>
                                <span class="milestone-check">[OK]</span>
                            `;
                            milestonesList.appendChild(item);
                        });
                    } else {
                        // Show message if no completed milestones yet
                        const noCompleted = document.createElement('div');
                        noCompleted.style.color = '#666';
                        noCompleted.style.fontStyle = 'italic';
                        noCompleted.style.textAlign = 'center';
                        noCompleted.textContent = 'NO_MILESTONES_COMPLETED';
                        milestonesList.appendChild(noCompleted);
                    }
                } else {
                    // Show message if no milestones
                    const noMilestones = document.createElement('div');
                    noMilestones.style.color = '#666';
                    noMilestones.style.fontStyle = 'italic';
                    noMilestones.textContent = 'NO_MILESTONES_LOADED';
                    milestonesList.appendChild(noMilestones);
                }
                
                // Add debug info if available - AFTER milestones
                if (data.current_location || data.badges !== undefined) {
                    const debugInfo = document.createElement('div');
                    debugInfo.style.fontSize = '10px';
                    debugInfo.style.color = '#666';
                    debugInfo.style.marginTop = '5px';
                    
                    let debugText = `
                        LOC: ${data.current_location || 'UNKNOWN'} | 
                        BADGES: ${data.badges || 0} | 
                        SEEN: ${data.pokedex_seen || 0} | 
                        CAUGHT: ${data.pokedex_caught || 0} | 
                        PARTY: ${data.party_size || 0}
                    `;
                    
                    // Add tracking system info if available
                    if (data.tracking_system) {
                        debugText += `<br/>TRACKING: ${data.tracking_system.toUpperCase()}`;
                        if (data.milestone_file) {
                            debugText += ` | FILE: ${data.milestone_file}`;
                        }
                    }
                    
                    debugInfo.innerHTML = debugText;
                    
                    // Remove old debug info
                    const oldDebug = milestonesList.querySelector('.debug-info');
                    if (oldDebug) oldDebug.remove();
                    
                    debugInfo.className = 'debug-info';
                    milestonesList.appendChild(debugInfo);
                }
                
            } catch (error) {
                console.error('Error fetching milestones:', error);
                // Show error in the UI
                const milestonesList = document.getElementById('milestones-list');
                milestonesList.innerHTML = `<div style="color: #ff6177;">ERROR: ${error.message}</div>`;
                
                // Also update the count to show error state
                document.getElementById('milestone-count').textContent = 'ERROR';
                document.getElementById('milestone-progress-fill').style.width = '0%';
            }
        }

        // Function to fetch and update party status
        async function updatePartyStatus() {
            try {
                const response = await fetch(`${serverUrl}/state`);
                const data = await response.json();
                
                const partyContainer = document.getElementById('party-status');
                partyContainer.innerHTML = '';
                
                if (data.player && data.player.party && data.player.party.length > 0) {
                    data.player.party.forEach(pokemon => {
                        if (pokemon && pokemon.species_name && pokemon.species_name.trim() !== '') {
                            const pokemonDiv = document.createElement('div');
                            pokemonDiv.className = 'party-pokemon';
                            
                            const hpPercent = pokemon.current_hp && pokemon.max_hp ? 
                                (pokemon.current_hp / pokemon.max_hp) * 100 : 0;
                            
                            let hpClass = 'hp-fill';
                            if (hpPercent < 25) hpClass += ' critical';
                            else if (hpPercent < 50) hpClass += ' low';
                            
                            let movesHtml = '';
                            if (pokemon.moves && pokemon.moves.length > 0) {
                                const validMoves = pokemon.moves.filter((moveName, index) => {
                                    if (!moveName) return false;
                                    const cleanName = moveName.toString().trim().toLowerCase();
                                    return cleanName !== '' && 
                                           cleanName !== '(none)' && 
                                           cleanName !== 'none' && 
                                           cleanName !== 'null' &&
                                           cleanName !== 'undefined';
                                });
                                
                                if (validMoves.length > 0) {
                                    movesHtml = '<div class="pokemon-moves">';
                                    pokemon.moves.forEach((moveName, index) => {
                                        if (moveName) {
                                            const cleanName = moveName.toString().trim().toLowerCase();
                                            if (cleanName !== '' && 
                                                cleanName !== '(none)' && 
                                                cleanName !== 'none' && 
                                                cleanName !== 'null' &&
                                                cleanName !== 'undefined') {
                                                const currentPp = pokemon.move_pp && pokemon.move_pp[index] !== undefined ? pokemon.move_pp[index] : '?';
                                                movesHtml += `<div class="move-item">
                                                    <span class="move-name">${moveName.toUpperCase()}</span>
                                                    <span>${currentPp} PP</span>
                                                </div>`;
                                            }
                                        }
                                    });
                                    movesHtml += '</div>';
                                }
                            }
                            
                            const displayName = (pokemon.nickname && pokemon.nickname.trim() !== '') ? 
                                pokemon.nickname.toUpperCase() : pokemon.species_name.toUpperCase();
                            
                            pokemonDiv.innerHTML = `
                                <div class="pokemon-header">
                                    <span class="pokemon-name">${displayName}</span>
                                    <span class="pokemon-level">Lv.${pokemon.level || '??'}</span>
                                </div>
                                <div class="pokemon-hp">
                                    <span>HP:</span>
                                    <div class="hp-bar">
                                        <div class="${hpClass}" style="width: ${hpPercent}%"></div>
                                    </div>
                                    <span>${pokemon.current_hp || '??'}/${pokemon.max_hp || '??'}</span>
                                </div>
                                ${movesHtml}
                            `;
                            
                            partyContainer.appendChild(pokemonDiv);
                        }
                    });
                } else {
                    // Fallback if no party data
                    partyContainer.innerHTML = `
                        <div class="party-pokemon">
                            <div class="pokemon-header">
                                <span class="pokemon-name">NO_PARTY_DATA</span>
                                <span class="pokemon-level">Lv.--</span>
                            </div>
                            <div class="pokemon-hp">
                                <span>HP:</span>
                                <div class="hp-bar">
                                    <div class="hp-fill" style="width: 0%"></div>
                                </div>
                                <span>--/--</span>
                            </div>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Error fetching party status:', error);
            }
        }

        // Frame updates are already handled by pollFrameUpdate()
        // No need for updateScreenshot()

        // Initialize streaming for agent thinking
        initializeAgentStreaming();

        // Set up periodic updates for other components - optimized frequencies
        setInterval(() => {
            updateRecentActions();
            updatePartyStatus();
        }, 2000); // Update every 2 seconds (reduced from 1s)

        // Less frequent updates for milestones  
        setInterval(() => {
            updateMilestones();
        }, 10000); // Update every 10 seconds (reduced from 5s)

        // Call the update functions initially (except agent thinking which streams)
        updateRecentActions();
        updateMilestones();
        updatePartyStatus();
    </script>
</body>
</html>